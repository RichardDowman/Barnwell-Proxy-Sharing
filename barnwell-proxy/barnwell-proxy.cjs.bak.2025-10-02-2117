/**
 * Barnwell Grill Proxy (CommonJS) — with order persistence + Square webhook -> optional EPOS forward
 * - Keeps ALL your existing endpoints & behavior
 * - Adds DATA_DIR/orders persistence on create-checkout-link (stores payment_link_id, url, receipt, payload)
 * - Adds POST /api/square-webhook (optional signature verify) and optional forward to EPOS when payment completes
 * - Adds GET /api/admin/orders (protected) for quick troubleshooting
 *
 * ENV (in /etc/barnwell-proxy.env):
 *   Core:
 *     PORT=8080
 *     DATA_DIR=/var/www/barnwell-proxy/data
 *   CORS:
 *     CORS_ORIGINS=https://barnwellgrill.gbapps.cmslogin.io
 *   Admin:
 *     ADMIN_TOKEN=...                # required for /api/admin/*
 *   Square:
 *     SQUARE_ENV=production|sandbox
 *     SQUARE_ACCESS_TOKEN=...
 *     SQUARE_LOCATION_ID=...
 *     CHECKOUT_RETURN_URL=https://barnwellgrill.gbapps.cmslogin.io/ordering?paid=1
 *     (or ORDERING_RETURN_URL=...; either works)
 *   Webhook (optional but recommended):
 *     SQUARE_WEBHOOK_SIGNATURE_KEY=...   # enables HMAC verify of webhook body
 *   EPOS (optional; set only if you want the proxy to POST the order to an EPOS endpoint):
 *     EPOS_URL=https://your-epos.example/api/orders
 *     EPOS_AUTH_HEADER="Bearer your-token-here"  # sent as Authorization header
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const express = require('express');

/* ---------------- ENV LOADER ---------------- */
(function loadEnvFile() {
  try {
    const p = '/etc/barnwell-proxy.env';
    if (fs.existsSync(p)) {
      const txt = fs.readFileSync(p, 'utf8');
      for (const line of txt.split(/\r?\n/)) {
        const m = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)\s*$/);
        if (!m) continue;
        const k = m[1]; let v = m[2];
        if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) v = v.slice(1, -1);
        if (!(k in process.env)) process.env[k] = v;
      }
    }
  } catch (_) { /* ignore */ }
})();

/* ---------------- CONFIG ---------------- */
const PORT = parseInt(process.env.PORT || '8080', 10);
const DATA_DIR = process.env.DATA_DIR || path.join(__dirname, 'data');
const ORDERS_DIR = path.join(DATA_DIR, 'orders');

const ADMIN_TOKEN = (process.env.ADMIN_TOKEN || '').trim();
const GOOGLE_MAPS_API_KEY = process.env.GOOGLE_MAPS_API_KEY || '';

const corsList = (process.env.CORS_ORIGINS || process.env.CORS_ALLOW_ORIGINS || 'https://barnwellgrill.gbapps.cmslogin.io')
  .split(',').map(s => s.trim()).filter(Boolean);

const SQUARE_ACCESS_TOKEN = process.env.SQUARE_ACCESS_TOKEN || '';
const SQUARE_ENV = (process.env.SQUARE_ENV || 'production').toLowerCase();
const SQUARE_BASE = SQUARE_ENV === 'sandbox' ? 'https://connect.squareupsandbox.com' : 'https://connect.squareup.com';
const SQUARE_LOCATION_ID = process.env.SQUARE_LOCATION_ID || '';
const CHECKOUT_RETURN_URL = process.env.CHECKOUT_RETURN_URL || process.env.ORDERING_RETURN_URL ||
  'https://barnwellgrill.gbapps.cmslogin.io/ordering?paid=1';
const SQUARE_WEBHOOK_SIGNATURE_KEY = process.env.SQUARE_WEBHOOK_SIGNATURE_KEY || '';

const EPOS_URL = process.env.EPOS_URL || '';
const EPOS_AUTH_HEADER = process.env.EPOS_AUTH_HEADER || '';

/* Ensure data dirs exist */
try { fs.mkdirSync(DATA_DIR, { recursive: true }); } catch (e) {}
try { fs.mkdirSync(ORDERS_DIR, { recursive: true }); } catch (e) {}

const settingsFile = path.join(DATA_DIR, 'settings.json');
const zonesFile = path.join(DATA_DIR, 'zones.json');

/* Defaults if files missing (unchanged from your version) */
if (!fs.existsSync(settingsFile)) {
  fs.writeFileSync(settingsFile, JSON.stringify({
    businessHours: {
      days: Array.from({ length: 7 }, () => ({ open: '11:00', close: '22:00', closed: false })),
      leadTimeMinutes: 30,
      allowPreorderDays: 1,
      closed: false,
      reopenAt: null
    },
    slotConfig: {
      collection: { granularity_minutes: 30, min_lead_minutes: 30, min_order_pence: 800 },
      delivery: { granularity_minutes: 30, min_lead_minutes: 45, min_order_pence: 1200 }
    },
    weekly: undefined
  }, null, 2));
}
if (!fs.existsSync(zonesFile)) {
  fs.writeFileSync(zonesFile, JSON.stringify({ zones: [] }, null, 2));
}

/* --------------- HELPERS ---------------- */
const fetch = global.fetch || ((...a) => Promise.reject(new Error('fetch not available')));
const readJSON = (f, fb = null) => { try { return JSON.parse(fs.readFileSync(f, 'utf8')); } catch (_) { return fb; } };
const writeJSON = (f, o) => fs.writeFileSync(f, JSON.stringify(o, null, 2));
const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
const money = (pence) => '£' + (Number(pence || 0) / 100).toFixed(2);

/* CORS */
function setCors(req, res) {
  const origin = req.headers.origin || '';
  if (!origin) { res.setHeader('Access-Control-Allow-Origin', '*'); return; }
  if (corsList.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Vary', 'Origin');
  } else {
    res.setHeader('Access-Control-Allow-Origin', corsList[0] || '*');
    res.setHeader('Vary', 'Origin');
  }
}
function cors(req, res, next) {
  setCors(req, res);
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Admin-Token, ngrok-skip-browser-warning, x-square-signature, x-square-hmacsha256-signature');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS');
  if (req.method === 'OPTIONS') return res.status(204).end();
  next();
}

/* Geocode helpers (same behavior as your version) */
async function geocodePostcodeWithPostcodesIo(pc) {
  try {
    const r = await fetch('https://api.postcodes.io/postcodes/' + encodeURIComponent(pc), { method: 'GET' });
    const j = await r.json().catch(() => null);
    return j;
  } catch (e) { return null; }
}

/* Point in polygon */
function pointInRing(lng, lat, ring) {
  if (!Array.isArray(ring) || ring.length < 3) return false;
  let inside = false;
  for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    const xi = Number(ring[i][0]), yi = Number(ring[i][1]);
    const xj = Number(ring[j][0]), yj = Number(ring[j][1]);
    const intersect = ((yi > lat) !== (yj > lat)) &&
      (lng < (xj - xi) * (lat - yi) / ((yj - yi) || 1e-12) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

/* Phone + name helpers (same as your version) */
function normalizePhoneUK(phone) {
  if (!phone) return '';
  let s = String(phone || '').trim().replace(/[().\-\s]/g, '');
  if (s.startsWith('00')) s = '+' + s.slice(2);
  if (/^0\d{9,10}$/.test(s)) s = '+44' + s.slice(1);
  if (/^\d{10,11}$/.test(s)) s = '+44' + s;
  if (/^\+\d{7,15}$/.test(s)) return s;
  const digits = s.replace(/\D/g, '');
  if (/^\d{10,11}$/.test(digits)) return '+44' + digits;
  if (/^\d{7,15}$/.test(digits)) return '+' + digits;
  return '';
}
function splitNameForSquare(fullName) {
  if (!fullName) return { given_name: '', family_name: '' };
  const parts = String(fullName).trim().split(/\s+/);
  if (parts.length === 1) return { given_name: parts[0], family_name: '' };
  return { given_name: parts[0], family_name: parts.slice(1).join(' ') };
}

/* Receipt (unchanged from your version) */
function buildReceipt(payload) {
  const width = 63;
  const dash = '-'.repeat(width);
  const items = Array.isArray(payload.items) ? payload.items : [];
  const fee = clamp(Number(payload.delivery_fee_pence || 0), 0, 10_000_000);
  const meta = payload.meta || {};
  const customer = meta.customer || {};
  const fulfilment = (meta.fulfilment || 'collection').toLowerCase();
  const scheduledAt = meta.scheduled_at ? new Date(meta.scheduled_at) : null;

  let dateStr = 'ASAP';
  if (scheduledAt && !isNaN(scheduledAt)) {
    const day = scheduledAt.getDate();
    const month = scheduledAt.toLocaleString('default', { month: 'short' });
    const time = scheduledAt.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    let suffix = 'th';
    if (![11,12,13].includes(day % 100)) {
      if (day % 10 === 1) suffix = 'st';
      else if (day % 10 === 2) suffix = 'nd';
      else if (day % 10 === 3) suffix = 'rd';
    }
    dateStr = `${day}${suffix} ${month} @ ${time}`;
  }

  const lines = [];
  lines.push('                             ORDER');
  lines.push(`ORDER TYPE = ${fulfilment.toUpperCase()}`);
  lines.push(`ORDER DATE = ${dateStr}`);
  lines.push('');
  lines.push(`Name: ${customer.name || ''}`);
  lines.push(`Phone: ${customer.phone || ''}`);
  if (fulfilment === 'delivery' && meta.address) lines.push(`Address: ${meta.address}`);
  lines.push('');
  lines.push(dash);

  for (const it of items) {
    const qty = Number(it.quantity || 1) || 1;
    const unitPence = Number(it.unit_pence || 0) || 0;
    const totalPence = unitPence * qty;
    const baseName = String(it.name || 'Item');
    const itemLine = qty > 1 ? `${baseName} (+${qty - 1})` : baseName;
    const priceText = money(totalPence);
    const leftWidth = width - priceText.length;
    lines.push((itemLine.length > leftWidth ? itemLine.slice(0, leftWidth) : itemLine).padEnd(leftWidth, ' ') + priceText);

    if (Array.isArray(it.groups)) {
      for (const g of it.groups) {
        if (!g || !g.name) continue;
        const vals = Array.isArray(g.values) ? g.values.filter(Boolean) : [];
        if (vals.length === 0) continue;
        lines.push(`${g.name}: ${vals.join(', ')}`);
      }
    }
    lines.push(dash);
  }

  const subtotal = items.reduce((s, it) => s + (Number(it.unit_pence || 0) * (Number(it.quantity || 1) || 1)), 0);
  const total = subtotal + fee;

  const totalsLine = (label, amount) => {
    const lbl = label.toUpperCase() + ':';
    const amt = money(amount);
    const space = width - lbl.length - amt.length;
    return lbl + (space > 0 ? ' '.repeat(space) : ' ') + amt;
  };

  lines.push(totalsLine('SUBTOTAL', subtotal));
  lines.push(totalsLine('DELIVERY FEE', fee));
  lines.push(totalsLine('TOTAL', total));
  lines.push('');

  return lines.join('\n');
}

/* ---------- Order persistence helpers ---------- */
function saveOrder(orderRef, data) {
  const p = path.join(ORDERS_DIR, orderRef + '.json');
  const prev = readJSON(p, {});
  writeJSON(p, Object.assign({}, prev, data));
}
function loadOrder(orderRef) {
  return readJSON(path.join(ORDERS_DIR, orderRef + '.json'), null);
}
function findOrderByPaymentLinkId(paymentLinkId) {
  const files = fs.readdirSync(ORDERS_DIR).filter(f => f.endsWith('.json'));
  for (const f of files) {
    const o = readJSON(path.join(ORDERS_DIR, f), null);
    if (o && o.payment_link_id === paymentLinkId) return o;
  }
  return null;
}

/* ---------- EPOS forward (optional) ---------- */
async function forwardToEpos(bodyObj) {
  if (!EPOS_URL) return { ok: false, reason: 'no_epos_url' };
  try {
    const r = await fetch(EPOS_URL, {
      method: 'POST',
      headers: Object.assign({
        'Content-Type': 'application/json',
        'Idempotency-Key': bodyObj.order_ref || crypto.randomUUID()
      }, EPOS_AUTH_HEADER ? { 'Authorization': EPOS_AUTH_HEADER } : {}),
      body: JSON.stringify(bodyObj)
    });
    const txt = await r.text().catch(() => '');
    if (r.ok) return { ok: true, response: txt };
    return { ok: false, status: r.status, detail: txt };
  } catch (e) {
    return { ok: false, error: String(e) };
  }
}

/* ---------- Webhook signature verify (optional) ---------- */
function verifySquareSignature(rawBodyBuffer, headers) {
  if (!SQUARE_WEBHOOK_SIGNATURE_KEY) return { ok: true, reason: 'no_key' };
  const h = headers['x-square-signature'] || headers['x-square-hmacsha256-signature'] || headers['x-square-signature'.toLowerCase()];
  if (!h) return { ok: false, reason: 'missing_signature_header' };
  try {
    const b64 = crypto.createHmac('sha256', SQUARE_WEBHOOK_SIGNATURE_KEY).update(rawBodyBuffer).digest('base64');
    if (b64 === h) return { ok: true };
    const hex = crypto.createHmac('sha256', SQUARE_WEBHOOK_SIGNATURE_KEY).update(rawBodyBuffer).digest('hex');
    if (hex === h) return { ok: true };
    return { ok: false, expected: b64, got: h };
  } catch (e) {
    return { ok: false, error: String(e) };
  }
}

/* ---------------- EXPRESS ---------------- */
const app = express();
app.use(express.json({ limit: '2mb' }));
app.use(cors);

/* ----------- ROUTES (everything you had, unchanged) ----------- */
app.get('/api/health', (req, res) => {
  setCors(req, res);
  res.json({ ok: true, env: SQUARE_ENV });
});

app.get('/api/settings', (req, res) => {
  setCors(req, res);
  const j = readJSON(settingsFile, {});
  const out = {
    businessHours: j.businessHours || {},
    slotConfig: j.slotConfig || {},
    manualClose: j.manualClose || { closed: false, reopenAt: null },
    manualClosed: !!(j.manualClose && j.manualClose.closed),
    reopenAt: j.manualClose ? j.manualClose.reopenAt : null,
    weekly: j.weekly || undefined
  };
  res.json(out);
});

/* Admin settings (GET/POST/PUT) */
function checkAdmin(req, res) {
  if (!ADMIN_TOKEN) { res.status(500).json({ error: 'admin_token_not_configured' }); return false; }
  const header = (req.headers['x-admin-token'] || '').trim();
  if (!header || header !== ADMIN_TOKEN) { res.status(401).json({ error: 'unauthorized' }); return false; }
  return true;
}
app.get('/api/admin/settings', (req, res) => { setCors(req, res); if (!checkAdmin(req, res)) return; res.json(readJSON(settingsFile, {})); });
app.post('/api/admin/settings', (req, res) => {
  setCors(req, res);
  if (!checkAdmin(req, res)) return;
  try {
    const merged = Object.assign({}, readJSON(settingsFile, {}) || {}, req.body || {});
    writeJSON(settingsFile, merged);
    res.json({ ok: true, saved: true });
  } catch (e) { res.status(500).json({ error: 'save_failed', detail: String(e?.message || e) }); }
});
app.put('/api/admin/settings', (req, res) => {
  setCors(req, res);
  if (!checkAdmin(req, res)) return;
  try {
    const merged = Object.assign({}, readJSON(settingsFile, {}) || {}, req.body || {});
    writeJSON(settingsFile, merged);
    res.json({ ok: true, saved: true });
  } catch (e) { res.status(500).json({ error: 'save_failed', detail: String(e?.message || e) }); }
});

/* Zones */
app.get('/api/zonesPublic', (req, res) => { setCors(req, res); res.json({ zones: (readJSON(zonesFile, { zones: [] }).zones || []) }); });
app.get('/api/zones', (req, res) => { setCors(req, res); res.json({ zones: (readJSON(zonesFile, { zones: [] }).zones || []) }); });

/* Geocode (same behavior) */
app.get('/api/geocode', async (req, res) => {
  try {
    setCors(req, res);
    const postcode = (req.query.postcode || req.query.address || '').trim();
    if (!postcode) return res.status(400).json({ results: [], status: 'ZERO_RESULTS', error: 'no_postcode' });

    if (GOOGLE_MAPS_API_KEY) {
      const url = 'https://maps.googleapis.com/maps/api/geocode/json?address=' +
        encodeURIComponent(postcode + ', UK') + '&key=' + encodeURIComponent(GOOGLE_MAPS_API_KEY);
      const r = await fetch(url, { method: 'GET' });
      const j = await r.json().catch(() => null);
      if (!j) return res.status(502).json({ results: [], status: 'ZERO_RESULTS' });
      return res.json(j);
    }

    const pj = await geocodePostcodeWithPostcodesIo(postcode).catch(() => null);
    if (!pj || !pj.result) return res.json({ results: [], status: 'ZERO_RESULTS' });
    const p = pj.result;
    const formatted = [p.admin_ward, p.parliamentary_constituency, p.postcode, p.region, p.country]
      .filter(Boolean).join(', ') || p.postcode || postcode;
    return res.json({
      results: [{ formatted_address: formatted, geometry: { location: { lat: p.latitude, lng: p.longitude } }, postcode: p.postcode, country: p.country }],
      status: 'OK'
    });
  } catch (e) { return res.status(500).json({ results: [], status: 'ERROR', error: String(e?.message || e) }); }
});

/* Delivery price */
app.post('/api/delivery-price', express.json(), async (req, res) => {
  try {
    setCors(req, res);
    const { postcode, lat, lng } = req.body || {};
    let L = (typeof lat === 'number') ? lat : null;
    let G = (typeof lng === 'number') ? lng : null;

    if ((L == null || G == null) && postcode) {
      try {
        if (GOOGLE_MAPS_API_KEY) {
          const r = await fetch('https://maps.googleapis.com/maps/api/geocode/json?address=' + encodeURIComponent(postcode + ', UK') + '&key=' + encodeURIComponent(GOOGLE_MAPS_API_KEY));
          const j = await r.json().catch(() => null);
          const loc = j?.results?.[0]?.geometry?.location;
          if (loc) { L = loc.lat; G = loc.lng; }
        } else {
          const pj = await geocodePostcodeWithPostcodesIo(postcode).catch(() => null);
          if (pj && pj.result) { L = pj.result.latitude; G = pj.result.longitude; }
        }
      } catch (_) {}
    }

    if (L == null || G == null) {
      return res.json({
        deliverable: false,
        reason: 'no_location',
        min_order_pence: (readJSON(settingsFile, {}).slotConfig?.delivery?.min_order_pence || 1200)
      });
    }

    const zones = readJSON(zonesFile, { zones: [] }).zones || [];
    let hit = null;
    for (const z of zones) {
      if (z.active === false) continue;
      const ring = z?.polygon?.coordinates?.[0] || z.ring || z.coordinates || null;
      if (!Array.isArray(ring) || ring.length < 3) continue;
      if (pointInRing(G, L, ring)) { hit = z; break; }
    }
    if (!hit) {
      return res.json({
        deliverable: false,
        matched: false,
        min_order_pence: (readJSON(settingsFile, {}).slotConfig?.delivery?.min_order_pence || 1200)
      });
    }

    res.json({
      deliverable: true,
      matched: true,
      zoneName: hit.name || hit.id || 'Zone',
      price_pence: Number(hit.price_pence || 0),
      min_order_pence: (readJSON(settingsFile, {}).slotConfig?.delivery?.min_order_pence || 1200)
    });
  } catch (e) {
    res.status(500).json({ error: 'quote_failed', detail: String(e?.message || e) });
  }
});

/* Catalog (Square) */
app.get('/api/catalogEverything', async (req, res) => {
  try {
    setCors(req, res);
    const types = String(req.query.types || 'ITEM,ITEM_VARIATION,CATEGORY,MODIFIER_LIST,ITEM_OPTION')
      .split(',').map(s => s.trim().toUpperCase()).filter(Boolean).join(',');
    if (!SQUARE_ACCESS_TOKEN) return res.status(500).json({ error: 'no_square_token' });

    let cursor = null;
    const objects = [];
    const related = [];
    do {
      const body = { types, include_related_objects: true };
      if (cursor) body.cursor = cursor;
      const r = await fetch(`${SQUARE_BASE}/v2/catalog/search`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${SQUARE_ACCESS_TOKEN}`, 'Square-Version': '2024-08-15', 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(() => null);
      if (!r.ok) return res.status(500).json({ error: 'square_catalog_error', status: r.status, detail: j });
      if (Array.isArray(j.objects)) objects.push(...j.objects);
      if (Array.isArray(j.related_objects)) related.push(...j.related_objects);
      cursor = j.cursor || null;
    } while (cursor);

    res.json({ objects: [...objects, ...related] });
  } catch (e) { res.status(500).json({ error: 'catalog_failed', detail: String(e?.message || e) }); }
});

/* Create checkout link — ADD: persist order for webhook -> EPOS */
app.post('/api/create-checkout-link', async (req, res) => {
  try {
    setCors(req, res);
    const payload = req.body || {};
    const items = Array.isArray(payload.items) ? payload.items : [];
    const deliveryFee = clamp(Number(payload.delivery_fee_pence || 0), 0, 10_000_000);
    const subtotal = items.reduce((s, it) => s + (Number(it.unit_pence || 0) * (Number(it.quantity || 1) || 1)), 0);
    const totalPence = subtotal + deliveryFee;
    const meta = payload.meta || {};
    const customer = meta.customer || {};

    if (!SQUARE_ACCESS_TOKEN || !SQUARE_LOCATION_ID) return res.status(500).json({ ok: false, error: 'square_config_missing' });
    if (!totalPence || totalPence <= 0) return res.status(400).json({ ok: false, error: 'invalid_total' });

    const printable_receipt = buildReceipt(payload);

    const pre = {};
    if (customer.phone) {
      const norm = normalizePhoneUK(customer.phone);
      if (norm && /^\+\d{7,15}$/.test(norm)) pre.buyer_phone_number = norm;
    }
    if (customer.name) {
      const nm = splitNameForSquare(customer.name);
      if (nm.given_name) pre.buyer_given_name = nm.given_name;
      if (nm.family_name) pre.buyer_family_name = nm.family_name;
    }
    if (customer.email && String(customer.email).includes('@')) pre.buyer_email = customer.email;

    const orderRef = crypto.randomUUID();
    let returnUrl = CHECKOUT_RETURN_URL || '';
    if (returnUrl) returnUrl += (returnUrl.includes('?') ? '&' : '?') + 'paid=1&ref=' + orderRef;

    const body = {
      idempotency_key: orderRef,
      quick_pay: {
        location_id: SQUARE_LOCATION_ID,
        name: payload.title || 'Barnwell Grill Order',
        price_money: { amount: totalPence, currency: String(payload.currency || 'GBP').toUpperCase() }
      },
      pre_populated_data: Object.keys(pre).length ? pre : undefined,
      checkout_options: returnUrl ? { redirect_url: returnUrl } : undefined
    };

    const r = await fetch(`${SQUARE_BASE}/v2/online-checkout/payment-links`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${SQUARE_ACCESS_TOKEN}`, 'Square-Version': '2024-08-15', 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    const j = await r.json().catch(() => null);

    // fallback without prefill if it failed due to phone/email etc.
    if (!r.ok) {
      if (body.pre_populated_data) {
        const fb = Object.assign({}, body); delete fb.pre_populated_data;
        const r2 = await fetch(`${SQUARE_BASE}/v2/online-checkout/payment-links`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${SQUARE_ACCESS_TOKEN}`, 'Square-Version': '2024-08-15', 'Content-Type': 'application/json' },
          body: JSON.stringify(fb)
        });
        const j2 = await r2.json().catch(() => null);
        if (r2.ok) {
          const url2 = j2?.payment_link?.url || j2?.url || null;
          const plid2 = j2?.payment_link?.id || null;
          saveOrder(orderRef, {
            order_ref: orderRef,
            payload, printable_receipt,
            created_at: new Date().toISOString(),
            payment_link_id: plid2,
            payment_link_url: url2,
            total_pence: totalPence,
            sentToEpos: false
          });
          return res.json({ ok: true, method: 'square.payment-links', url: url2, printable_receipt, order_ref: orderRef, payment_link_id: plid2 });
        }
      }
      return res.status(502).json({ ok: false, error: 'square_payment_link_failed', status: r.status, detail: j });
    }

    const url = j?.payment_link?.url || j?.url || null;
    const paymentLinkId = j?.payment_link?.id || null;

    // persist for webhook match
    saveOrder(orderRef, {
      order_ref: orderRef,
      payload, printable_receipt,
      created_at: new Date().toISOString(),
      payment_link_id: paymentLinkId,
      payment_link_url: url,
      total_pence: totalPence,
      sentToEpos: false
    });

    res.json({ ok: true, method: 'square.payment-links', url, printable_receipt, order_ref: orderRef, payment_link_id: paymentLinkId });
  } catch (e) {
    res.status(500).json({ ok: false, error: 'create_checkout_failed', detail: String(e?.message || e) });
  }
});

/* ---------- Admin orders list (for quick troubleshooting) ---------- */
app.get('/api/admin/orders', (req, res) => {
  setCors(req, res);
  if (!ADMIN_TOKEN || (req.headers['x-admin-token'] || '').trim() !== ADMIN_TOKEN) {
    return res.status(401).json({ error: 'unauthorized' });
  }
  try {
    const files = fs.readdirSync(ORDERS_DIR).filter(f => f.endsWith('.json'));
    res.json({ orders: files.map(f => ({ file: f, data: readJSON(path.join(ORDERS_DIR, f), {}) })) });
  } catch (e) {
    res.status(500).json({ error: 'list_failed', detail: String(e) });
  }
});

/* ---------- Square Webhook (server->server, raw body for HMAC) ---------- */
app.post('/api/square-webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  try {
    const raw = req.body; // Buffer
    const headers = Object.fromEntries(Object.entries(req.headers).map(([k, v]) => [k.toLowerCase(), v]));
    const verify = verifySquareSignature(raw, headers);
    if (!verify.ok && SQUARE_WEBHOOK_SIGNATURE_KEY) {
      return res.status(401).send('signature_mismatch');
    }

    const evt = JSON.parse(raw.toString('utf8'));
    const eventType = evt?.type || evt?.event_type || '';
    const payment = evt?.data?.object?.payment || null;

    // Try to match saved order using payment_link_id
    const paymentLinkId = payment?.payment_link_id || payment?.link_id || payment?.source_details?.payment_link_id;
    let order = paymentLinkId ? findOrderByPaymentLinkId(paymentLinkId) : null;

    // Fallback match by reference/note if present
    if (!order) {
      const maybeRef = payment?.reference_id || payment?.note || payment?.order_id || payment?.metadata?.order_ref;
      if (maybeRef) order = loadOrder(String(maybeRef));
    }

    if (!order) {
      const unmatched = path.join(ORDERS_DIR, `unmatched-${Date.now()}-${payment?.id || 'evt'}.json`);
      fs.writeFileSync(unmatched, JSON.stringify({ received_at: new Date().toISOString(), event: evt }, null, 2));
      return res.status(200).json({ ok: true, matched: false });
    }

    // enrich & persist payment info
    const status = payment?.status || '';
    order.payment = { id: payment?.id || null, status, raw: payment };
    saveOrder(order.order_ref, order);

    const isCompleted = /COMPLETED|PAID|CAPTURED/i.test(status) || /payment\.created/i.test(eventType);
    if (!isCompleted) return res.status(200).json({ ok: true, matched: true, completed: false, status });

    // Forward to EPOS (optional)
    if (!order.sentToEpos && EPOS_URL) {
      const forwardBody = {
        order_ref: order.order_ref,
        created_at: order.created_at,
        total_pence: order.total_pence,
        printable_receipt: order.printable_receipt,
        items: order.payload?.items || [],
        delivery_fee_pence: order.payload?.delivery_fee_pence || 0,
        meta: order.payload?.meta || {},
        payment: order.payment || {}
      };
      const r = await forwardToEpos(forwardBody);
      if (r.ok) {
        saveOrder(order.order_ref, Object.assign({}, order, { sentToEpos: true, eposResponse: r.response || '' }));
      } else {
        saveOrder(order.order_ref, Object.assign({}, order, { eposStatus: r.status || null, eposError: r.error || null, eposResponse: r.detail || '' }));
      }
      return res.status(200).json({ ok: true, matched: true, forwarded: r });
    }

    return res.status(200).json({ ok: true, matched: true, completed: true, forwarded: EPOS_URL ? false : 'no_epos_url' });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e) });
  }
});

/* --------------- START --------------- */
app.listen(PORT, () => {
  console.log(`barnwell-proxy (orders + webhook) listening on :${PORT}`);
});
